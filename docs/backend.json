{
  "entities": {
    "ChickenBatch": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChickenBatch",
      "type": "object",
      "description": "Represents a batch of chickens with shared characteristics and lifecycle management.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the chicken batch."
        },
        "breed": {
          "type": "string",
          "description": "The breed of chickens in this batch."
        },
        "hatchDate": {
          "type": "string",
          "description": "The date when the chicks in this batch hatched.",
          "format": "date-time"
        },
        "quantity": {
          "type": "number",
          "description": "The initial number of chicks in the batch."
        },
        "currentQuantity": {
          "type": "number",
          "description": "The current number of chickens in the batch, accounting for sales, losses, etc."
        },
        "housingId": {
          "type": "string",
          "description": "Reference to Housing where this batch is located. (Relationship: Housing 1:N ChickenBatch)"
        },
        "feedTypeId": {
          "type": "string",
          "description": "Reference to FeedType used for this batch. (Relationship: FeedType 1:N ChickenBatch)"
        }
      },
      "required": [
        "id",
        "breed",
        "hatchDate",
        "quantity",
        "currentQuantity",
        "housingId",
        "feedTypeId"
      ]
    },
    "Housing": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Housing",
      "type": "object",
      "description": "Represents a physical structure or area where chickens are housed.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the housing unit."
        },
        "name": {
          "type": "string",
          "description": "A descriptive name for the housing unit (e.g., Coop 1, Barn A)."
        },
        "capacity": {
          "type": "number",
          "description": "The maximum number of chickens that can be housed in this unit."
        },
        "type": {
          "type": "string",
          "description": "The type of housing (e.g., coop, barn, free-range area)."
        },
        "temperatureSensorId": {
          "type": "string",
          "description": "Reference to TemperatureSensor associated with this Housing. (Relationship: TemperatureSensor 1:1 Housing)"
        }
      },
      "required": [
        "id",
        "name",
        "capacity",
        "type",
        "temperatureSensorId"
      ]
    },
    "FeedType": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FeedType",
      "type": "object",
      "description": "Represents different types of feed used for the chickens.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the feed type."
        },
        "name": {
          "type": "string",
          "description": "The name of the feed type (e.g., Starter, Grower, Finisher)."
        },
        "description": {
          "type": "string",
          "description": "A description of the feed type, including its composition and intended use."
        },
        "nutrientProfile": {
          "type": "string",
          "description": "JSON string that shows the nutrient information about this feed"
        }
      },
      "required": [
        "id",
        "name",
        "description",
        "nutrientProfile"
      ]
    },
    "TemperatureSensor": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TemperatureSensor",
      "type": "object",
      "description": "Represents a temperature sensor that collects data within a housing unit.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the temperature sensor."
        },
        "sensorName": {
          "type": "string",
          "description": "A descriptive name for the sensor (e.g., Coop 1 - Sensor A)."
        },
        "lastReading": {
          "type": "number",
          "description": "The most recent temperature reading from the sensor (in Celsius)."
        },
        "lastReadingTimestamp": {
          "type": "string",
          "description": "The timestamp of the last temperature reading.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "sensorName",
        "lastReading",
        "lastReadingTimestamp"
      ]
    },
    "Alert": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Alert",
      "type": "object",
      "description": "Represents an alert generated by the system based on predefined rules or AI predictions.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the alert."
        },
        "batchId": {
          "type": "string",
          "description": "Reference to ChickenBatch that triggered this alert. (Relationship: ChickenBatch 1:N Alert)"
        },
        "type": {
          "type": "string",
          "description": "The type of alert (e.g., TemperatureHigh, FeedConsumptionLow, PredictedDisease)."
        },
        "severity": {
          "type": "string",
          "description": "The severity of the alert (e.g., Low, Medium, High)."
        },
        "message": {
          "type": "string",
          "description": "A detailed message describing the alert and its potential impact."
        },
        "timestamp": {
          "type": "string",
          "description": "The timestamp when the alert was generated.",
          "format": "date-time"
        },
        "isResolved": {
          "type": "boolean",
          "description": "Indicates whether the alert has been resolved."
        }
      },
      "required": [
        "id",
        "batchId",
        "type",
        "severity",
        "message",
        "timestamp",
        "isResolved"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the CluckHub system.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "firstName": {
          "type": "string",
          "description": "The first name of the user."
        },
        "lastName": {
          "type": "string",
          "description": "The last name of the user."
        },
        "email": {
          "type": "string",
          "description": "The email address of the user.",
          "format": "email"
        },
        "role": {
          "type": "string",
          "description": "The role of the user (e.g., admin, worker, vet)."
        }
      },
      "required": [
        "id",
        "firstName",
        "lastName",
        "email",
        "role"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. Path-based ownership ensures only the user can access their profile.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user, matching Firebase auth UID."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/housing/{housingId}",
        "definition": {
          "entityName": "Housing",
          "schema": {
            "$ref": "#/backend/entities/Housing"
          },
          "description": "Stores housing information owned by the user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "housingId",
              "description": "The unique ID of the housing."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/feedTypes/{feedTypeId}",
        "definition": {
          "entityName": "FeedType",
          "schema": {
            "$ref": "#/backend/entities/FeedType"
          },
          "description": "Stores feed types owned by the user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "feedTypeId",
              "description": "The unique ID of the feed type."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/temperatureSensors/{temperatureSensorId}",
        "definition": {
          "entityName": "TemperatureSensor",
          "schema": {
            "$ref": "#/backend/entities/TemperatureSensor"
          },
          "description": "Stores temperature sensors owned by the user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "temperatureSensorId",
              "description": "The unique ID of the temperature sensor."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/chickenBatches/{chickenBatchId}",
        "definition": {
          "entityName": "ChickenBatch",
          "schema": {
            "$ref": "#/backend/entities/ChickenBatch"
          },
          "description": "Stores chicken batch information owned by the user. Includes denormalized 'ownerId' field for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "chickenBatchId",
              "description": "The unique ID of the chicken batch."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/chickenBatches/{chickenBatchId}/alerts/{alertId}",
        "definition": {
          "entityName": "Alert",
          "schema": {
            "$ref": "#/backend/entities/Alert"
          },
          "description": "Stores alerts related to a chicken batch, owned by the user. Includes denormalized 'ownerId' (inherited from ChickenBatch) field for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique ID of the user."
            },
            {
              "name": "chickenBatchId",
              "description": "The unique ID of the chicken batch."
            },
            {
              "name": "alertId",
              "description": "The unique ID of the alert."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support CluckHub's core features while adhering to the principles of Authorization Independence, Clarity of Intent, DBAC, and QAPs. The structure leverages path-based ownership for user-specific data and membership maps for collaborative data. Denormalization is extensively used to avoid `get()` calls in security rules, thus ensuring atomic operations and easier debugging. Segregation ensures that each collection has a homogeneous security posture, which simplifies security rule definition and prevents unintended access.\n\nSpecifically, user-owned data such as Housing, FeedType, and TemperatureSensor are placed under `/users/{userId}` to ensure that only the owning user has access. ChickenBatches are similarly organized under the user's path. Alerts, which are related to ChickenBatches, inherit this ownership through their location within the user's subcollection. The structure facilitates secure `list` operations because all documents in a collection share the same security requirements enforced by path-based rules.\n\nAuthorization Independence is achieved by including a `ownerId` field in the ChickenBatch and Alert entities, which duplicates the user ID owning these documents. This allows security rules to validate ownership without needing to perform a `get()` on a parent document. This is especially critical for atomicity during creation. The membership map strategy (not explicitly used here due to lack of collaborative entities) would involve denormalizing user roles into documents needing collaborative access, avoiding dependency on custom claims.\n\nThe DBAC principle is enforced by storing the user role directly in the User document. This avoids the need for custom claims. Instead, roles are read directly from the database during authorization.\n\nQAPs are achieved via the data structure; listing of `chickenBatches` can be limited via rules ensuring `request.auth.uid == chickenBatches.ownerId`"
  }
}