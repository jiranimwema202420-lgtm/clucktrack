/**
 * @fileoverview Firestore Security Rules for the CluckTrack Application
 * @author expert-firebase-rules-architect
 *
 * @description
 * This ruleset enforces a strict user-ownership model combined with a global,
 * existence-based role system for administrative access. The core philosophy is
 * to ensure that all user-generated data is private by default, accessible only
 * to the user who created it.
 *
 * ## Core Philosophy
 * The security model is built on two main principles:
 * 1.  **Path-Based Ownership**: All user-specific data (batches, poultry, sensor
 *     data, etc.) is stored in subcollections under `/users/{userId}`. This
 *     structurally isolates user data, making it easy to write clear and
 *     performant rules that grant access only to the authenticated owner.
 * 2.  **Global Admin Roles**: A top-level `/roles_admin` collection manages
 *     administrative privileges. A user is considered an admin if a document
 *     with their UID exists in this collection. Admins have write access to
 *     globally managed data, such as the `/feeds` catalog.
 *
 * ## Data Structure
 * - `/users/{userId}`: The root for all data owned by a specific user.
 *   - `/users/{userId}/batches/{batchId}`: A user's poultry batches.
 *     - `/users/{userId}/batches/{batchId}/poultry/{poultryId}`: Individual birds within a batch.
 *     - `/users/{userId}/batches/{batchId}/feedConsumption/{feedConsumptionId}`: Feed records for a batch.
 *     - `/users/{userId}/batches/{batchId}/alerts/{alertId}`: System alerts for a batch.
 *   - `/users/{userId}/sensorData/{sensorDataId}`: IoT sensor data linked to a user.
 * - `/feeds/{feedId}`: A global catalog of feed types, readable by all signed-in users but writable only by admins.
 * - `/roles_admin/{userId}`: An existence-based collection to grant users admin privileges.
 *
 * ## Key Security Decisions
 * - **No User Enumeration**: Listing the top-level `/users` collection is explicitly disallowed to protect user privacy.
 * - **Denormalization for Authorization**: To ensure performant and secure access checks within subcollections, authorization-critical fields like `batchId` are denormalized onto child documents (e.g., Poultry, FeedConsumption). The rules enforce the integrity of these links on create and their immutability on update.
 * - **Admin-Managed Global Data**: Collections like `/feeds` and `/roles_admin` are managed exclusively by users with the 'admin' role, separating administrative tasks from standard user operations.
 * - **Default Deny**: Any operation not explicitly granted is denied.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * @description Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requesting user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     * @param userId The UID of the document owner.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the resource being accessed already exists.
     * Crucial for protecting against writes to non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * @description Combines ownership and existence checks for secure updates and deletes.
     * @param userId The UID of the document owner.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Checks if the requesting user has admin privileges.
     * Role is granted by the existence of a document in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    // -------------------------------------------------------------------------
    // User Data
    // -------------------------------------------------------------------------

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own profile document.
     * @deny (list) Another user cannot list all user profiles.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description A user's collection of poultry batches.
       * @path /users/{userId}/batches/{batchId}
       * @allow (create) The owner can create a new batch in their own collection.
       * @deny (get) Another user cannot read the owner's batch data.
       * @principle Enforces strict ownership for all nested user data.
       */
      match /batches/{batchId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);

        /**
         * @description Individual poultry records within a batch.
         * @path /users/{userId}/batches/{batchId}/poultry/{poultryId}
         * @allow (create) The owner can add a poultry record to their own batch.
         * @deny (update) Another user cannot update a poultry record.
         * @principle Validates relational integrity between a parent batch and a child poultry record.
         */
        match /poultry/{poultryId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId) && request.resource.data.batchId == batchId;
          allow update: if isExistingOwner(userId) && request.resource.data.batchId == resource.data.batchId;
          allow delete: if isExistingOwner(userId);
        }

        /**
         * @description Feed consumption records for a specific batch.
         * @path /users/{userId}/batches/{batchId}/feedConsumption/{feedConsumptionId}
         * @allow (create) The owner can add a feed consumption record to their own batch.
         * @deny (create) The owner cannot create a record with a mismatched batchId.
         * @principle Validates relational integrity between a parent batch and a child consumption record.
         */
        match /feedConsumption/{feedConsumptionId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId) && request.resource.data.batchId == batchId;
          allow update: if isExistingOwner(userId) && request.resource.data.batchId == resource.data.batchId;
          allow delete: if isExistingOwner(userId);
        }

        /**
         * @description System alerts associated with a specific batch.
         * @path /users/{userId}/batches/{batchId}/alerts/{alertId}
         * @allow (list) The owner can list all alerts for their batch.
         * @deny (delete) Another user cannot delete an alert from the owner's batch.
         * @principle Validates relational integrity between a parent batch and a child alert.
         */
        match /alerts/{alertId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId) && request.resource.data.batchId == batchId;
          allow update: if isExistingOwner(userId) && request.resource.data.batchId == resource.data.batchId;
          allow delete: if isExistingOwner(userId);
        }
      }

      /**
       * @description IoT sensor data owned by the user.
       * @path /users/{userId}/sensorData/{sensorDataId}
       * @allow (get) The owner can read their own sensor data.
       * @deny (list) Another user cannot list the owner's sensor data.
       * @principle Enforces strict ownership for all user data.
       */
      match /sensorData/{sensorDataId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
    }

    // -------------------------------------------------------------------------
    // Global & Admin-Managed Data
    // -------------------------------------------------------------------------

    /**
     * @description A global catalog of feed types.
     * @path /feeds/{feedId}
     * @allow (list) Any authenticated user can list all available feed types.
     * @deny (create) A non-admin user cannot create a new feed type.
     * @principle Allows public read for authenticated users but restricts writes to admins.
     */
    match /feeds/{feedId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Manages admin role grants. Document existence confers admin rights.
     * @path /roles_admin/{userId}
     * @allow (create) An existing admin can grant admin rights to another user.
     * @deny (delete) A non-admin user cannot revoke admin rights.
     * @principle Secures role management by restricting modifications to existing admins.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin() && isExistingDoc();
    }
  }
}